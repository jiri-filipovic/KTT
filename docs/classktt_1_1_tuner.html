<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kernel Tuning Toolkit: ktt::Tuner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kernel Tuning Toolkit
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classktt_1_1_tuner.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classktt_1_1_tuner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ktt::Tuner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tuner__api_8h_source.html">tuner_api.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a12bf48c69b2cb1836b7f854ab89dba97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a12bf48c69b2cb1836b7f854ab89dba97">Tuner</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform, const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a> device)</td></tr>
<tr class="separator:a12bf48c69b2cb1836b7f854ab89dba97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b49b872dad86f4ce1c4d02d63a39ffc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a0b49b872dad86f4ce1c4d02d63a39ffc">Tuner</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform, const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a> device, const <a class="el" href="namespacektt.html#a319c9e3d66dd23fdd4f71b0c467d3b59">ComputeAPI</a> computeAPI)</td></tr>
<tr class="separator:a0b49b872dad86f4ce1c4d02d63a39ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f9416c764b3792a83f177324963aff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a43f9416c764b3792a83f177324963aff">Tuner</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform, const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a> device, const <a class="el" href="namespacektt.html#a319c9e3d66dd23fdd4f71b0c467d3b59">ComputeAPI</a> computeAPI, const uint32_t computeQueueCount)</td></tr>
<tr class="separator:a43f9416c764b3792a83f177324963aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09198b07768176d263dbee8a6c54b377"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a09198b07768176d263dbee8a6c54b377">~Tuner</a> ()</td></tr>
<tr class="separator:a09198b07768176d263dbee8a6c54b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e45834abd29265b4221ccb2bd28c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#af4e45834abd29265b4221ccb2bd28c2c">addKernel</a> (const std::string &amp;source, const std::string &amp;kernelName, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)</td></tr>
<tr class="separator:af4e45834abd29265b4221ccb2bd28c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f12acd6cabf05acc4085979573b86f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a98f12acd6cabf05acc4085979573b86f">addKernelFromFile</a> (const std::string &amp;filePath, const std::string &amp;kernelName, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)</td></tr>
<tr class="separator:a98f12acd6cabf05acc4085979573b86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75abfd603f8dd9df7661ebf89635a9eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a75abfd603f8dd9df7661ebf89635a9eb">setKernelArguments</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;argumentIds)</td></tr>
<tr class="separator:a75abfd603f8dd9df7661ebf89635a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae876ca213d4c7f2a52dff449f8cc9424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ae876ca213d4c7f2a52dff449f8cc9424">addParameter</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;parameterName, const std::vector&lt; size_t &gt; &amp;parameterValues)</td></tr>
<tr class="separator:ae876ca213d4c7f2a52dff449f8cc9424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34e3dca1bccd8020feca575c9386e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#af34e3dca1bccd8020feca575c9386e9f">addParameterDouble</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;parameterName, const std::vector&lt; double &gt; &amp;parameterValues)</td></tr>
<tr class="separator:af34e3dca1bccd8020feca575c9386e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee879e5da70866d321960026ee8f281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a7ee879e5da70866d321960026ee8f281">addParameterPack</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;packName, const std::vector&lt; std::string &gt; &amp;parameterNames)</td></tr>
<tr class="separator:a7ee879e5da70866d321960026ee8f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb4ecdde64d7bb80759fa446cd0dff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a8fb4ecdde64d7bb80759fa446cd0dff1">setThreadModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> modifierType, const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> modifierDimension, const std::vector&lt; std::string &gt; &amp;parameterNames, const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;modifierFunction)</td></tr>
<tr class="separator:a8fb4ecdde64d7bb80759fa446cd0dff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f6b2785bfa64b659914525916acfef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a72f6b2785bfa64b659914525916acfef">setThreadModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> modifierType, const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> modifierDimension, const std::string &amp;parameterName, const <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a> modifierAction)</td></tr>
<tr class="separator:a72f6b2785bfa64b659914525916acfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571ef8d31c049dae3b3e132cf293f23e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a571ef8d31c049dae3b3e132cf293f23e">setLocalMemoryModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> argumentId, const std::vector&lt; std::string &gt; &amp;parameterNames, const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;modifierFunction)</td></tr>
<tr class="separator:a571ef8d31c049dae3b3e132cf293f23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd05fc8da9961240428cd8bb35b0b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a6bd05fc8da9961240428cd8bb35b0b65">addConstraint</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; std::string &gt; &amp;parameterNames, const std::function&lt; bool(const std::vector&lt; size_t &gt; &amp;)&gt; &amp;constraintFunction)</td></tr>
<tr class="separator:a6bd05fc8da9961240428cd8bb35b0b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2def6687ce5048047786008a819a2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa2def6687ce5048047786008a819a2d2">setTuningManipulator</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, std::unique_ptr&lt; <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a> &gt; manipulator)</td></tr>
<tr class="separator:aa2def6687ce5048047786008a819a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72e9d52720d83fc8622920536df15d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa72e9d52720d83fc8622920536df15d7">setTuningManipulatorSynchronization</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const bool flag)</td></tr>
<tr class="separator:aa72e9d52720d83fc8622920536df15d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e396b2a8a183e00efd3eb8ac10a839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ac9e396b2a8a183e00efd3eb8ac10a839">addComposition</a> (const std::string &amp;compositionName, const std::vector&lt; <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> &gt; &amp;kernelIds, std::unique_ptr&lt; <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a> &gt; manipulator)</td></tr>
<tr class="separator:ac9e396b2a8a183e00efd3eb8ac10a839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83979059b4be0835cffbaf154353e946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a83979059b4be0835cffbaf154353e946">setCompositionKernelThreadModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> compositionId, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> kernelId, const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> modifierType, const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> modifierDimension, const std::vector&lt; std::string &gt; &amp;parameterNames, const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;modifierFunction)</td></tr>
<tr class="separator:a83979059b4be0835cffbaf154353e946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc813e3cef10dd070924009537de5cde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#acc813e3cef10dd070924009537de5cde">setCompositionKernelThreadModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> compositionId, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> kernelId, const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> modifierType, const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> modifierDimension, const std::string &amp;parameterName, const <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a> modifierAction)</td></tr>
<tr class="separator:acc813e3cef10dd070924009537de5cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59ec5d56969e61102e4e86925f082fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ae59ec5d56969e61102e4e86925f082fd">setCompositionKernelLocalMemoryModifier</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> compositionId, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> kernelId, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> argumentId, const std::vector&lt; std::string &gt; &amp;parameterNames, const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;modifierFunction)</td></tr>
<tr class="separator:ae59ec5d56969e61102e4e86925f082fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285180cce4d6aa3decc0faf2f610061e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a285180cce4d6aa3decc0faf2f610061e">setCompositionKernelArguments</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> compositionId, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> kernelId, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;argumentIds)</td></tr>
<tr class="separator:a285180cce4d6aa3decc0faf2f610061e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2680ebeab8011862b75ff74c76f302ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2680ebeab8011862b75ff74c76f302ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a2680ebeab8011862b75ff74c76f302ed">addArgumentVector</a> (const std::vector&lt; T &gt; &amp;data, const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> accessType)</td></tr>
<tr class="separator:a2680ebeab8011862b75ff74c76f302ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373cc33d23fcaf51bfb4fa79e28693ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a373cc33d23fcaf51bfb4fa79e28693ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a373cc33d23fcaf51bfb4fa79e28693ea">addArgumentVector</a> (std::vector&lt; T &gt; &amp;data, const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> accessType, const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> memoryLocation, const bool copyData)</td></tr>
<tr class="separator:a373cc33d23fcaf51bfb4fa79e28693ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0875ba38133723a9d9ebac79521e9fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0875ba38133723a9d9ebac79521e9fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa0875ba38133723a9d9ebac79521e9fe">addArgumentScalar</a> (const T &amp;data)</td></tr>
<tr class="separator:aa0875ba38133723a9d9ebac79521e9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70540aa13df443505a690d24824af8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a70540aa13df443505a690d24824af8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a1a70540aa13df443505a690d24824af8">addArgumentLocal</a> (const size_t localMemoryElementsCount)</td></tr>
<tr class="separator:a1a70540aa13df443505a690d24824af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fbc48ae700252317b7ba6f48a46072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a32fbc48ae700252317b7ba6f48a46072">persistArgument</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const bool flag)</td></tr>
<tr class="separator:a32fbc48ae700252317b7ba6f48a46072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0c877d952683b26bd17e1aa3daa123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#afc0c877d952683b26bd17e1aa3daa123">downloadPersistentArgument</a> (const <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &amp;output) const</td></tr>
<tr class="separator:afc0c877d952683b26bd17e1aa3daa123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e5fc88cd393aea02eb9f7b099c6109"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a15e5fc88cd393aea02eb9f7b099c6109">tuneKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)</td></tr>
<tr class="separator:a15e5fc88cd393aea02eb9f7b099c6109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44ca3e81c04c5278e1b3ede95c39201"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa44ca3e81c04c5278e1b3ede95c39201">tuneKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, std::unique_ptr&lt; <a class="el" href="classktt_1_1_stop_condition.html">StopCondition</a> &gt; stopCondition)</td></tr>
<tr class="separator:aa44ca3e81c04c5278e1b3ede95c39201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ce9d97c6618e4ccf573210932141b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a572ce9d97c6618e4ccf573210932141b">dryTuneKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;filePath, const size_t iterations=0)</td></tr>
<tr class="separator:a572ce9d97c6618e4ccf573210932141b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c62e9e550a857082facfd9d129eaa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ae5c62e9e550a857082facfd9d129eaa5">tuneKernelByStep</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &gt; &amp;output)</td></tr>
<tr class="separator:ae5c62e9e550a857082facfd9d129eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a0a5e8a7dac656ab8eadcb727cd16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a040a0a5e8a7dac656ab8eadcb727cd16">tuneKernelByStep</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &gt; &amp;output, const bool recomputeReference)</td></tr>
<tr class="separator:a040a0a5e8a7dac656ab8eadcb727cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a1dd869be5455e5eafd7e641ac636b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ab0a1dd869be5455e5eafd7e641ac636b">runKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;configuration, const std::vector&lt; <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &gt; &amp;output)</td></tr>
<tr class="separator:ab0a1dd869be5455e5eafd7e641ac636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf97c52c83ff51f391b05b6d8ea1e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a7cf97c52c83ff51f391b05b6d8ea1e50">clearKernelData</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const bool clearConfigurations)</td></tr>
<tr class="separator:a7cf97c52c83ff51f391b05b6d8ea1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6291e47775d9059cdfe1dda017624dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a6291e47775d9059cdfe1dda017624dbb">setKernelProfiling</a> (const bool flag)</td></tr>
<tr class="separator:a6291e47775d9059cdfe1dda017624dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90b7b5b9aad38d0cc367d17a1501dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ab90b7b5b9aad38d0cc367d17a1501dba">setCompositionKernelProfiling</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> compositionId, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> kernelId, const bool flag)</td></tr>
<tr class="separator:ab90b7b5b9aad38d0cc367d17a1501dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f722474ac405d70d579e707fe80caa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a3f722474ac405d70d579e707fe80caa5">setKernelProfilingCounters</a> (const std::vector&lt; std::string &gt; &amp;counterNames)</td></tr>
<tr class="separator:a3f722474ac405d70d579e707fe80caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2201bd0031520e6bc520a827ec74f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#abdd2201bd0031520e6bc520a827ec74f">setSearchMethod</a> (const <a class="el" href="namespacektt.html#a5f5b49f1e11331a499aa44fb1fa6788b">SearchMethod</a> method, const std::vector&lt; double &gt; &amp;arguments)</td></tr>
<tr class="separator:abdd2201bd0031520e6bc520a827ec74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad679eb4f58e26571bf8d88086fec8f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ad679eb4f58e26571bf8d88086fec8f47">setPrintingTimeUnit</a> (const <a class="el" href="namespacektt.html#a161b9af8714615ef2c1770b020ce1511">TimeUnit</a> unit)</td></tr>
<tr class="separator:ad679eb4f58e26571bf8d88086fec8f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97c7b552373a7daba908d98cf5528c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ae97c7b552373a7daba908d98cf5528c7">setInvalidResultPrinting</a> (const bool flag)</td></tr>
<tr class="separator:ae97c7b552373a7daba908d98cf5528c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad337e3eed6589bbdf82ac636a276f43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aad337e3eed6589bbdf82ac636a276f43">printResult</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, std::ostream &amp;outputTarget, const <a class="el" href="namespacektt.html#a241748d791d84aed146db202c8b68beb">PrintFormat</a> format) const</td></tr>
<tr class="separator:aad337e3eed6589bbdf82ac636a276f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc514761cffce0ecf4895af32f40011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a6cc514761cffce0ecf4895af32f40011">printResult</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::string &amp;filePath, const <a class="el" href="namespacektt.html#a241748d791d84aed146db202c8b68beb">PrintFormat</a> format) const</td></tr>
<tr class="separator:a6cc514761cffce0ecf4895af32f40011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a312f0107da50d83a7135e56c5fc447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a4a312f0107da50d83a7135e56c5fc447">getBestComputationResult</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id) const</td></tr>
<tr class="separator:a4a312f0107da50d83a7135e56c5fc447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222360db3b296745fdc6b7fd2784b0bd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a222360db3b296745fdc6b7fd2784b0bd">getKernelSource</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;configuration) const</td></tr>
<tr class="separator:a222360db3b296745fdc6b7fd2784b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebd071678533e08b361ee6e40bbc96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aaebd071678533e08b361ee6e40bbc96e">setReferenceKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> referenceId, const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;referenceConfiguration, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;validatedArgumentIds)</td></tr>
<tr class="separator:aaebd071678533e08b361ee6e40bbc96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84062246cb9d65e816ed70965fa4d499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a84062246cb9d65e816ed70965fa4d499">setReferenceClass</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, std::unique_ptr&lt; <a class="el" href="classktt_1_1_reference_class.html">ReferenceClass</a> &gt; referenceClass, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;validatedArgumentIds)</td></tr>
<tr class="separator:a84062246cb9d65e816ed70965fa4d499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa648b6c2492c4f13c13a7fcae2a02c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa648b6c2492c4f13c13a7fcae2a02c92">setValidationMode</a> (const <a class="el" href="namespacektt.html#a3baf318a03750f7418a5faa051967c04">ValidationMode</a> mode)</td></tr>
<tr class="separator:aa648b6c2492c4f13c13a7fcae2a02c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4562a0fbc7a0b9154225ff6697f09f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa4562a0fbc7a0b9154225ff6697f09f5">setValidationMethod</a> (const <a class="el" href="namespacektt.html#a187d4987bb48bc1f78f628c8aa840a20">ValidationMethod</a> method, const double toleranceThreshold)</td></tr>
<tr class="separator:aa4562a0fbc7a0b9154225ff6697f09f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e9d2eb698f8ae84f8f6c98f137c246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a70e9d2eb698f8ae84f8f6c98f137c246">setValidationRange</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const size_t range)</td></tr>
<tr class="separator:a70e9d2eb698f8ae84f8f6c98f137c246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55276ce6d9e56d0cbdf9e97678edd32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a55276ce6d9e56d0cbdf9e97678edd32f">setArgumentComparator</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const std::function&lt; bool(const void *, const void *)&gt; &amp;comparator)</td></tr>
<tr class="separator:a55276ce6d9e56d0cbdf9e97678edd32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e5fac57625bcb37497d37bd3562527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ad0e5fac57625bcb37497d37bd3562527">setCompilerOptions</a> (const std::string &amp;options)</td></tr>
<tr class="separator:ad0e5fac57625bcb37497d37bd3562527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35533400505de1ac1b809607308407b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa35533400505de1ac1b809607308407b">setKernelCacheCapacity</a> (const size_t capacity)</td></tr>
<tr class="separator:aa35533400505de1ac1b809607308407b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926dcf592dca93bb8bb7ff5bf53b6ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a926dcf592dca93bb8bb7ff5bf53b6ccd">printComputeAPIInfo</a> (std::ostream &amp;outputTarget) const</td></tr>
<tr class="separator:a926dcf592dca93bb8bb7ff5bf53b6ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484f25bb0659411c0986ff2344b4da37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_platform_info.html">PlatformInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a484f25bb0659411c0986ff2344b4da37">getPlatformInfo</a> () const</td></tr>
<tr class="separator:a484f25bb0659411c0986ff2344b4da37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66643af1ecdd8da030573a4f6c024a4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a66643af1ecdd8da030573a4f6c024a4f">getDeviceInfo</a> (const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a> platform) const</td></tr>
<tr class="separator:a66643af1ecdd8da030573a4f6c024a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2213d22fdd851759f81b29d11542576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa2213d22fdd851759f81b29d11542576">getCurrentDeviceInfo</a> () const</td></tr>
<tr class="separator:aa2213d22fdd851759f81b29d11542576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00574c195c9055e720685564314bbdb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a00574c195c9055e720685564314bbdb8">setAutomaticGlobalSizeCorrection</a> (const bool flag)</td></tr>
<tr class="separator:a00574c195c9055e720685564314bbdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa580eaa938ddd76552668d9191740636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa580eaa938ddd76552668d9191740636">setGlobalSizeType</a> (const <a class="el" href="namespacektt.html#a16e643cd2325370c79affaeee8ef85f0">GlobalSizeType</a> type)</td></tr>
<tr class="separator:aa580eaa938ddd76552668d9191740636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0c79c9e759300cfa89071ecbf8625351"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#a0c79c9e759300cfa89071ecbf8625351">setLoggingLevel</a> (const <a class="el" href="namespacektt.html#a17afdb449e82292a32fba46ff7a54781">LoggingLevel</a> level)</td></tr>
<tr class="separator:a0c79c9e759300cfa89071ecbf8625351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e0133a7e9ff598922468648cdaaa66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#aa3e0133a7e9ff598922468648cdaaa66">setLoggingTarget</a> (std::ostream &amp;outputTarget)</td></tr>
<tr class="separator:aa3e0133a7e9ff598922468648cdaaa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada578ea479190ebcbadef6873cd44092"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuner.html#ada578ea479190ebcbadef6873cd44092">setLoggingTarget</a> (const std::string &amp;filePath)</td></tr>
<tr class="separator:ada578ea479190ebcbadef6873cd44092"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which serves as the main part of public API of KTT framework. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a12bf48c69b2cb1836b7f854ab89dba97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bf48c69b2cb1836b7f854ab89dba97">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor, which creates new tuner object for specified platform and device. <a class="el" href="classktt_1_1_tuner.html">Tuner</a> uses OpenCL as compute API, all commands are submitted to a single compute queue. Indices for available platforms and devices can be retrieved by calling <a class="el" href="classktt_1_1_tuner.html#a926dcf592dca93bb8bb7ff5bf53b6ccd">printComputeAPIInfo()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index for platform used by created tuner. </td></tr>
    <tr><td class="paramname">device</td><td>Index for device used by created tuner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b49b872dad86f4ce1c4d02d63a39ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b49b872dad86f4ce1c4d02d63a39ffc">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a319c9e3d66dd23fdd4f71b0c467d3b59">ComputeAPI</a>&#160;</td>
          <td class="paramname"><em>computeAPI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor, which creates new tuner object for specified platform, device and compute API. All commands are submitted to a single compute queue. Indices for available platforms and devices can be retrieved by calling <a class="el" href="classktt_1_1_tuner.html#a926dcf592dca93bb8bb7ff5bf53b6ccd">printComputeAPIInfo()</a> method. If specified compute API is CUDA, platform index is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index for platform used by created tuner. </td></tr>
    <tr><td class="paramname">device</td><td>Index for device used by created tuner. </td></tr>
    <tr><td class="paramname">computeAPI</td><td>Compute API used by created tuner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43f9416c764b3792a83f177324963aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f9416c764b3792a83f177324963aff">&#9670;&nbsp;</a></span>Tuner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::Tuner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a19087697a405aa9def6c058d335c21ad">DeviceIndex</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a319c9e3d66dd23fdd4f71b0c467d3b59">ComputeAPI</a>&#160;</td>
          <td class="paramname"><em>computeAPI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>computeQueueCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor, which creates new tuner object for specified platform, device and compute API. Several compute queues are created, based on specified count. Commands to different queues can be submitted by utilizing <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a>. Indices for available platforms and devices can be retrieved by calling <a class="el" href="classktt_1_1_tuner.html#a926dcf592dca93bb8bb7ff5bf53b6ccd">printComputeAPIInfo()</a> method. If specified compute API is CUDA, platform index is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index for platform used by created tuner. </td></tr>
    <tr><td class="paramname">device</td><td>Index for device used by created tuner. </td></tr>
    <tr><td class="paramname">computeAPI</td><td>Compute API used by created tuner. </td></tr>
    <tr><td class="paramname">computeQueueCount</td><td>Number of compute queues created inside the tuner. Has to be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09198b07768176d263dbee8a6c54b377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09198b07768176d263dbee8a6c54b377">&#9670;&nbsp;</a></span>~Tuner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktt::Tuner::~Tuner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classktt_1_1_tuner.html">Tuner</a> destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a70540aa13df443505a690d24824af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a70540aa13df443505a690d24824af8">&#9670;&nbsp;</a></span>addArgumentLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::addArgumentLocal </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>localMemoryElementsCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds new local memory (shared memory in CUDA) argument to tuner. All local memory arguments are read-only and cannot be initialized from host memory. In case of CUDA API usage, local memory arguments cannot be directly set as kernel function arguments. Setting a local memory argument to kernel in CUDA means that corresponding amount of memory will be allocated for kernel to use. In that case, all local memory argument ids should be specified at the end of the vector when calling <a class="el" href="classktt_1_1_tuner.html#a75abfd603f8dd9df7661ebf89635a9eb">setKernelArguments()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localMemoryElementsCount</td><td>Specifies how many elements of provided data type the argument contains. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="aa0875ba38133723a9d9ebac79521e9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0875ba38133723a9d9ebac79521e9fe">&#9670;&nbsp;</a></span>addArgumentScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::addArgumentScalar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds new scalar argument to tuner. All scalar arguments are read-only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Argument data provided as single scalar value. The data type must be trivially copyable. Bool data type is currently not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a2680ebeab8011862b75ff74c76f302ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2680ebeab8011862b75ff74c76f302ed">&#9670;&nbsp;</a></span>addArgumentVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::addArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds new vector argument to tuner. Makes copy of argument data, so the source data vector remains unaffected by tuner operations. Argument data will be accessed from device memory during its usage by compute API. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Argument data provided in std::vector. Provided data type must be trivially copyable. Bool data type is currently not supported. </td></tr>
    <tr><td class="paramname">accessType</td><td>Access type of argument specifies whether argument is used for input or output. See <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a373cc33d23fcaf51bfb4fa79e28693ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373cc33d23fcaf51bfb4fa79e28693ea">&#9670;&nbsp;</a></span>addArgumentVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename T &gt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> ktt::Tuner::addArgumentVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a>&#160;</td>
          <td class="paramname"><em>memoryLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds new vector argument to tuner. Allows choice for argument memory location and whether argument data is copied to tuner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Argument data provided in std::vector. Provided data type must be trivially copyable. Bool data type is currently not supported. </td></tr>
    <tr><td class="paramname">accessType</td><td>Access type of argument specifies whether argument is used for input or output. See <a class="el" href="namespacektt.html#a42e64b6f9fe9ded7bad6b07cb9c53d35">ArgumentAccessType</a> for more information. </td></tr>
    <tr><td class="paramname">memoryLocation</td><td>Memory location of argument specifies whether argument will be accessed from device or host memory during its usage by compute API. See <a class="el" href="namespacektt.html#ac355e7acb6c66ab83a0238f94d880f62">ArgumentMemoryLocation</a> for more information. </td></tr>
    <tr><td class="paramname">copyData</td><td>Flag which specifies whether the argument is copied inside tuner. If set to false, tuner will store reference of source data vector and will access it directly during kernel launch operations. This results in lower memory overhead, but relies on a user to keep data in source vector valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel argument by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="ac9e396b2a8a183e00efd3eb8ac10a839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e396b2a8a183e00efd3eb8ac10a839">&#9670;&nbsp;</a></span>addComposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> ktt::Tuner::addComposition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compositionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernelIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a> &gt;&#160;</td>
          <td class="paramname"><em>manipulator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a kernel composition using specified kernels. The following methods can be used with kernel compositions and will call the corresponding method for all kernels inside the composition: <a class="el" href="classktt_1_1_tuner.html#a75abfd603f8dd9df7661ebf89635a9eb">setKernelArguments()</a>, <a class="el" href="classktt_1_1_tuner.html#ae876ca213d4c7f2a52dff449f8cc9424">addParameter()</a> (both versions), <a class="el" href="classktt_1_1_tuner.html#a6bd05fc8da9961240428cd8bb35b0b65">addConstraint()</a>.</p>
<p>Kernel compositions do not inherit any parameters or constraints from the original kernels. Setting kernel arguments and adding parameters or constraints to kernels inside given composition will not affect the original kernels or other compositions. Tuning manipulator is required in order to launch kernel composition with the tuner. See <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositionName</td><td>Name of kernel composition. The name is used during output printing. </td></tr>
    <tr><td class="paramname">kernelIds</td><td>Ids of kernels which will be included in the composition. </td></tr>
    <tr><td class="paramname">manipulator</td><td>Tuning manipulator for the composition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel composition by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a6bd05fc8da9961240428cd8bb35b0b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd05fc8da9961240428cd8bb35b0b65">&#9670;&nbsp;</a></span>addConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::addConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const std::vector&lt; size_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraintFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new constraint for specified kernel. Constraints are used to prevent generating of invalid configurations (eg. conflicting parameter values). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the constraint will be added. </td></tr>
    <tr><td class="paramname">parameterNames</td><td>Names of kernel parameters which will be affected by the constraint function. The order of parameter names corresponds to the order of parameter values inside the constraint function vector argument. </td></tr>
    <tr><td class="paramname">constraintFunction</td><td>Function which returns true if provided combination of parameter values is valid. Returns false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e45834abd29265b4221ccb2bd28c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e45834abd29265b4221ccb2bd28c2c">&#9670;&nbsp;</a></span>addKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> ktt::Tuner::addKernel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>kernelName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new kernel to tuner from source code inside string. Requires specification of kernel name and default global and local thread sizes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Kernel source code written in corresponding compute API language. </td></tr>
    <tr><td class="paramname">kernelName</td><td>Name of kernel function inside kernel source code. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for base kernel global size (eg. grid size in CUDA). </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for base kernel local size (eg. block size in CUDA). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="a98f12acd6cabf05acc4085979573b86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f12acd6cabf05acc4085979573b86f">&#9670;&nbsp;</a></span>addKernelFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> ktt::Tuner::addKernelFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>kernelName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new kernel to tuner from source code inside file. Requires specification of kernel name and default global and local thread sizes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to file with kernel source code written in corresponding compute API language. </td></tr>
    <tr><td class="paramname">kernelName</td><td>Name of kernel function inside kernel source code. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for base kernel global size (eg. grid size in CUDA). </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for base kernel local size (eg. block size in CUDA). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id assigned to kernel by tuner. The id can be used in other API methods. </dd></dl>

</div>
</div>
<a id="ae876ca213d4c7f2a52dff449f8cc9424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae876ca213d4c7f2a52dff449f8cc9424">&#9670;&nbsp;</a></span>addParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::addParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new integer parameter for specified kernel, providing parameter name and list of allowed values. When the corresponding kernel is launched, parameters will be added to kernel source code as preprocessor definitions. During the tuning process, tuner will generate configurations for combinations of kernel parameters and their values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the parameter will be added. </td></tr>
    <tr><td class="paramname">parameterName</td><td>Name of a parameter. Parameter names for single kernel must be unique. </td></tr>
    <tr><td class="paramname">parameterValues</td><td>Vector of allowed values for the parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34e3dca1bccd8020feca575c9386e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34e3dca1bccd8020feca575c9386e9f">&#9670;&nbsp;</a></span>addParameterDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::addParameterDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new floating-point parameter for specified kernel, providing parameter name and list of allowed values. When the corresponding kernel is launched, parameters will be added to kernel source code as preprocessor definitions. During the tuning process, tuner will generate configurations for combinations of kernel parameters and their values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the parameter will be added. </td></tr>
    <tr><td class="paramname">parameterName</td><td>Name of a parameter. Parameter names for single kernel must be unique. </td></tr>
    <tr><td class="paramname">parameterValues</td><td>Vector of allowed values for the parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ee879e5da70866d321960026ee8f281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee879e5da70866d321960026ee8f281">&#9670;&nbsp;</a></span>addParameterPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::addParameterPack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>packName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a pack containing specified kernel parameters. When parameter packs are used, tuning configurations are generated progressively for each pack. Once best configuration is found for a specific pack, next pack is then processed. This method is useful when kernels contain groups of parameters that can be tuned independently. The total number of generated configurations that need to be tested is reduced. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the parameter pack will be added. </td></tr>
    <tr><td class="paramname">packName</td><td>Name of a parameter pack. Parameter pack names for a single kernel must be unique. </td></tr>
    <tr><td class="paramname">parameterNames</td><td>Names of parameters which will be added to the parameter pack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf97c52c83ff51f391b05b6d8ea1e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf97c52c83ff51f391b05b6d8ea1e50">&#9670;&nbsp;</a></span>clearKernelData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::clearKernelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clearConfigurations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets tuning process and clears tuning results for specified kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel whose data will be cleared. </td></tr>
    <tr><td class="paramname">clearConfigurations</td><td>If true, generated kernel configurations will be cleared as well. Otherwise, they will remain inside tuner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc0c877d952683b26bd17e1aa3daa123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0c877d952683b26bd17e1aa3daa123">&#9670;&nbsp;</a></span>downloadPersistentArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::downloadPersistentArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downloads specified persistent argument from compute API buffer into specified memory location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>User-provided memory location for persistent kernel argument which should be retrieved. See <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a572ce9d97c6618e4ccf573210932141b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572ce9d97c6618e4ccf573210932141b">&#9670;&nbsp;</a></span>dryTuneKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> &gt; ktt::Tuner::dryTuneKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the simulated tuning process for specified kernel (kernel is not tuned, execution times are read from CSV). Creates configuration space based on combinations of provided kernel parameters and constraints. The configurations will be launched in order that depends on specified <a class="el" href="namespacektt.html#a5f5b49f1e11331a499aa44fb1fa6788b">SearchMethod</a>. This method can be used to test behaviour and performance of newly implemented search methods. Note that no checks are performed whether the tuning data relates to kernel, tuning parameters or hardware. It is up to user to ensure that <a class="el" href="classktt_1_1_tuner.html#a572ce9d97c6618e4ccf573210932141b">dryTuneKernel()</a> reads a valid file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning begins. </td></tr>
    <tr><td class="paramname">filePath</td><td>Path to CSV file with tuning parameters. </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of iterations performed, 0 = scan whole tuning space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of objects containing information about computation using tested kernel configurations. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<a id="a4a312f0107da50d83a7135e56c5fc447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a312f0107da50d83a7135e56c5fc447">&#9670;&nbsp;</a></span>getBestComputationResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> ktt::Tuner::getBestComputationResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the best computation result found for specified kernel. Valid result will be returned only if one of the kernel tuning methods was already called for corresponding kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the best result will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing information about best computation result for specified kernel. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<a id="aa2213d22fdd851759f81b29d11542576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2213d22fdd851759f81b29d11542576">&#9670;&nbsp;</a></span>getCurrentDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> ktt::Tuner::getCurrentDeviceInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves detailed information about device (eg. device name, memory capacity) used by the tuner. See <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> for more information. </p><dl class="section return"><dt>Returns</dt><dd>Information about device used by the tuner. </dd></dl>

</div>
</div>
<a id="a66643af1ecdd8da030573a4f6c024a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66643af1ecdd8da030573a4f6c024a4f">&#9670;&nbsp;</a></span>getDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> &gt; ktt::Tuner::getDeviceInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ace6bcecdbf444cc8adffa172168f8a47">PlatformIndex</a>&#160;</td>
          <td class="paramname"><em>platform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves detailed information about all available devices (eg. device name, memory capacity) on specified platform. See <a class="el" href="classktt_1_1_device_info.html">DeviceInfo</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">platform</td><td>Index of platform for which the device information will be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about all available devices on specified platform. </dd></dl>

</div>
</div>
<a id="a222360db3b296745fdc6b7fd2784b0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222360db3b296745fdc6b7fd2784b0bd">&#9670;&nbsp;</a></span>getKernelSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ktt::Tuner::getKernelSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns kernel source with preprocessor definitions for specified kernel based on provided configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the source is returned. </td></tr>
    <tr><td class="paramname">configuration</td><td>Kernel configuration for which the source will be generated. See <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kernel source with preprocessor definitions for specified kernel based on provided configuration. </dd></dl>

</div>
</div>
<a id="a484f25bb0659411c0986ff2344b4da37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484f25bb0659411c0986ff2344b4da37">&#9670;&nbsp;</a></span>getPlatformInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_platform_info.html">PlatformInfo</a> &gt; ktt::Tuner::getPlatformInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves detailed information about all available platforms (eg. platform name, vendor). See <a class="el" href="classktt_1_1_platform_info.html">PlatformInfo</a> for more information. </p><dl class="section return"><dt>Returns</dt><dd>Information about all available platforms. </dd></dl>

</div>
</div>
<a id="a32fbc48ae700252317b7ba6f48a46072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fbc48ae700252317b7ba6f48a46072">&#9670;&nbsp;</a></span>persistArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::persistArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls whether specified vector argument is persisted inside a compute API buffer or not. Persisted arguments remain inside buffers even after the execution of kernel utilizing these arguments has finished. Persistence of kernel arguments is switched off by default. Persistent arguments can be useful during online tuning and regular kernel running, when kernel output is computed over multiple kernel launches in different configurations. Note that persistent arguments are never utilized by reference kernels. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of a vector argument. </td></tr>
    <tr><td class="paramname">flag</td><td>Specifies whether argument should be persisted or not. If true, specified vector argument is immediately persisted. If false, compute API buffer for specified argument is immediately destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a926dcf592dca93bb8bb7ff5bf53b6ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926dcf592dca93bb8bb7ff5bf53b6ccd">&#9670;&nbsp;</a></span>printComputeAPIInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::printComputeAPIInfo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outputTarget</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints basic information about available platforms and devices to specified output stream. Also prints indices assigned to them by KTT framework. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputTarget</td><td>Location where the information will be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad337e3eed6589bbdf82ac636a276f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad337e3eed6589bbdf82ac636a276f43">&#9670;&nbsp;</a></span>printResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::printResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outputTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a241748d791d84aed146db202c8b68beb">PrintFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints tuning results for specified kernel to specified output stream. Valid results will be printed only if method <a class="el" href="classktt_1_1_tuner.html#a15e5fc88cd393aea02eb9f7b099c6109">tuneKernel()</a> or <a class="el" href="classktt_1_1_tuner.html#ae5c62e9e550a857082facfd9d129eaa5">tuneKernelByStep()</a> was already called for corresponding kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the results will be printed. </td></tr>
    <tr><td class="paramname">outputTarget</td><td>Location where the results will be printed. </td></tr>
    <tr><td class="paramname">format</td><td>Format in which the results will be printed. See <a class="el" href="namespacektt.html#a241748d791d84aed146db202c8b68beb">PrintFormat</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc514761cffce0ecf4895af32f40011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc514761cffce0ecf4895af32f40011">&#9670;&nbsp;</a></span>printResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::printResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a241748d791d84aed146db202c8b68beb">PrintFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints tuning results for specified kernel to specified file. Valid results will be printed only if method <a class="el" href="classktt_1_1_tuner.html#a15e5fc88cd393aea02eb9f7b099c6109">tuneKernel()</a> or <a class="el" href="classktt_1_1_tuner.html#ae5c62e9e550a857082facfd9d129eaa5">tuneKernelByStep()</a> was already called for corresponding kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the results will be printed. </td></tr>
    <tr><td class="paramname">filePath</td><td>Path to file where the results will be printed. </td></tr>
    <tr><td class="paramname">format</td><td>Format in which the results are printed. See <a class="el" href="namespacektt.html#a241748d791d84aed146db202c8b68beb">PrintFormat</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0a1dd869be5455e5eafd7e641ac636b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a1dd869be5455e5eafd7e641ac636b">&#9670;&nbsp;</a></span>runKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> ktt::Tuner::runKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs specified kernel using provided configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. </td></tr>
    <tr><td class="paramname">configuration</td><td>Configuration under which the kernel will be launched. See <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> for more information. </td></tr>
    <tr><td class="paramname">output</td><td>User-provided memory locations for kernel arguments which should be retrieved. See <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing information about computation using specified kernel configuration. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<a id="a55276ce6d9e56d0cbdf9e97678edd32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55276ce6d9e56d0cbdf9e97678edd32f">&#9670;&nbsp;</a></span>setArgumentComparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setArgumentComparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const void *, const void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets argument comparator for specified kernel argument. Arguments with custom data type cannot be compared using built-in comparison operators and require user to provide a comparator. Comparator can also be optionally added for arguments with built-in data types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the comparator will be set. </td></tr>
    <tr><td class="paramname">comparator</td><td>Function which receives two elements with data type matching the data type of specified kernel argument and returns true if the elements are equal. Returns false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00574c195c9055e720685564314bbdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00574c195c9055e720685564314bbdb8">&#9670;&nbsp;</a></span>setAutomaticGlobalSizeCorrection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setAutomaticGlobalSizeCorrection </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggles automatic correction for global size, which ensures that global size in each dimension is always a multiple of local size in corresponding dimension. Performs a roundup to the nearest higher multiple. Automatic global size correction is disabled by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If true, automatic global size correction will be enabled. It will be disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0e5fac57625bcb37497d37bd3562527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e5fac57625bcb37497d37bd3562527">&#9670;&nbsp;</a></span>setCompilerOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setCompilerOptions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets compute API compiler options to specified options. There are no default options for OpenCL back-end. Default option for CUDA back-end is "--gpu-architecture=compute_30".</p>
<p>For list of OpenCL compiler options, see: <a href="https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clBuildProgram.html">https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clBuildProgram.html</a> For list of CUDA compiler options, see: <a href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#nvcc-command-options">http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#nvcc-command-options</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Compute API compiler options. If multiple options are used, they need to be separated by a single space character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a285180cce4d6aa3decc0faf2f610061e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285180cce4d6aa3decc0faf2f610061e">&#9670;&nbsp;</a></span>setCompositionKernelArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setCompositionKernelArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>compositionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>kernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argumentIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classktt_1_1_tuner.html#a75abfd603f8dd9df7661ebf89635a9eb">setKernelArguments()</a> method for a single kernel inside specified kernel composition. Does not affect standalone kernels or other compositions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositionId</td><td>Id of composition which includes the specified kernel. </td></tr>
    <tr><td class="paramname">kernelId</td><td>Id of kernel inside the composition for which the arguments will be set. </td></tr>
    <tr><td class="paramname">argumentIds</td><td>Ids of arguments to be used by specified kernel inside the composition. Order of ids must match the order of kernel arguments specified in kernel function. Argument ids for single kernel must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae59ec5d56969e61102e4e86925f082fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59ec5d56969e61102e4e86925f082fd">&#9670;&nbsp;</a></span>setCompositionKernelLocalMemoryModifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setCompositionKernelLocalMemoryModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>compositionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>kernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>argumentId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>modifierFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classktt_1_1_tuner.html#a571ef8d31c049dae3b3e132cf293f23e">setLocalMemoryModifier()</a> method for a single kernel inside specified kernel composition. Does not affect standalone kernels or other compositions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositionId</td><td>Id of composition which includes the specified kernel. </td></tr>
    <tr><td class="paramname">kernelId</td><td>Id of kernel inside the composition for which the modifier will be set. </td></tr>
    <tr><td class="paramname">argumentId</td><td>Id of local memory kernel argument which will be affected by the modifier. </td></tr>
    <tr><td class="paramname">parameterNames</td><td>Names of kernel parameters whose values will be passed into the modifier function. The order of parameter names corresponds to the order of parameter values inside the modifier function vector argument. </td></tr>
    <tr><td class="paramname">modifierFunction</td><td>Function which receives size of specified local memory argument and values of specified kernel parameters as input and returns modified argument size based on these values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab90b7b5b9aad38d0cc367d17a1501dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90b7b5b9aad38d0cc367d17a1501dba">&#9670;&nbsp;</a></span>setCompositionKernelProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setCompositionKernelProfiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>compositionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>kernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggles profiling of a specific kernel inside kernel composition. This is useful if only some kernels inside the composition need to be profiled. By default, profiling is enabled for all kernels inside newly added kernel compositions. Note that this method has no effect if kernel profiling is completely disabled. See <a class="el" href="classktt_1_1_tuner.html#a6291e47775d9059cdfe1dda017624dbb">setKernelProfiling()</a> method for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositionId</td><td>Id of composition which includes the specified kernel. </td></tr>
    <tr><td class="paramname">kernelId</td><td>Id of kernel inside the composition for which the profiling flag will be set. </td></tr>
    <tr><td class="paramname">flag</td><td>If true, kernel profiling is enabled for specified kernel inside the composition. It is disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83979059b4be0835cffbaf154353e946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83979059b4be0835cffbaf154353e946">&#9670;&nbsp;</a></span>setCompositionKernelThreadModifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setCompositionKernelThreadModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>compositionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>kernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a>&#160;</td>
          <td class="paramname"><em>modifierType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a>&#160;</td>
          <td class="paramname"><em>modifierDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>modifierFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classktt_1_1_tuner.html#a8fb4ecdde64d7bb80759fa446cd0dff1">setThreadModifier()</a> method for a single kernel inside specified kernel composition. Does not affect standalone kernels or other compositions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositionId</td><td>Id of composition which includes the specified kernel. </td></tr>
    <tr><td class="paramname">kernelId</td><td>Id of kernel inside the composition for which the modifier will be set. </td></tr>
    <tr><td class="paramname">modifierType</td><td>Type of the thread modifier. See <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> for more information. </td></tr>
    <tr><td class="paramname">modifierDimension</td><td>Dimension which will be affected by the thread modifier. See <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> for more information. </td></tr>
    <tr><td class="paramname">parameterNames</td><td>Names of kernel parameters whose values will be passed into the modifier function. The order of parameter names corresponds to the order of parameter values inside the modifier function vector argument. </td></tr>
    <tr><td class="paramname">modifierFunction</td><td>Function which receives thread size in specified kernel dimension and values of specified kernel parameters as input and returns modified thread size based on these values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc813e3cef10dd070924009537de5cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc813e3cef10dd070924009537de5cde">&#9670;&nbsp;</a></span>setCompositionKernelThreadModifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setCompositionKernelThreadModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>compositionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>kernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a>&#160;</td>
          <td class="paramname"><em>modifierType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a>&#160;</td>
          <td class="paramname"><em>modifierDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a>&#160;</td>
          <td class="paramname"><em>modifierAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls simplified version of <a class="el" href="classktt_1_1_tuner.html#a8fb4ecdde64d7bb80759fa446cd0dff1">setThreadModifier()</a> method for a single kernel inside specified kernel composition. Does not affect standalone kernels or other compositions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositionId</td><td>Id of composition which includes the specified kernel. </td></tr>
    <tr><td class="paramname">kernelId</td><td>Id of kernel inside the composition for which the modifier will be set. </td></tr>
    <tr><td class="paramname">modifierType</td><td>Type of the thread modifier. See <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> for more information. </td></tr>
    <tr><td class="paramname">modifierDimension</td><td>Dimension which will be affected by the thread modifier. See <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> for more information. </td></tr>
    <tr><td class="paramname">parameterName</td><td>Name of a kernel parameter whose value will be utilized by the thread modifier. </td></tr>
    <tr><td class="paramname">modifierAction</td><td>Action of the thread modifier. See <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa580eaa938ddd76552668d9191740636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa580eaa938ddd76552668d9191740636">&#9670;&nbsp;</a></span>setGlobalSizeType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setGlobalSizeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a16e643cd2325370c79affaeee8ef85f0">GlobalSizeType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets global size specification type to specified compute API style. In OpenCL, NDrange size is specified as number of work-items in a work-group multiplied by number of work-groups. In CUDA, grid size is specified as number of blocks. This method makes it possible to use OpenCL style in CUDA and vice versa. Default global size type is the one corresponding to compute API of the tuner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Global size type which will be set for tuner. See <a class="el" href="namespacektt.html#a16e643cd2325370c79affaeee8ef85f0">GlobalSizeType</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97c7b552373a7daba908d98cf5528c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97c7b552373a7daba908d98cf5528c7">&#9670;&nbsp;</a></span>setInvalidResultPrinting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setInvalidResultPrinting </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggles printing of results from failed kernel runs. Invalid results will be separated from valid results during printing. Printing of invalid results is disabled by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If true, printing of invalid results will be enabled. It will be disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75abfd603f8dd9df7661ebf89635a9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75abfd603f8dd9df7661ebf89635a9eb">&#9670;&nbsp;</a></span>setKernelArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setKernelArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argumentIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets kernel arguments for specified kernel by providing corresponding argument ids. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the arguments will be set. </td></tr>
    <tr><td class="paramname">argumentIds</td><td>Ids of arguments to be used by specified kernel. Order of ids must match the order of kernel arguments specified in kernel function. Argument ids for single kernel must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa35533400505de1ac1b809607308407b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35533400505de1ac1b809607308407b">&#9670;&nbsp;</a></span>setKernelCacheCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setKernelCacheCapacity </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets capacity of kernel cache inside the tuner. The cache contains recently compiled kernels which are prepared to be launched immidiately, eliminating compilation overhead. Using the cache can significantly improve tuner performance during online tuning or iterative kernel running with <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a>. Default cache size is 10. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Controls kernel cache capacity. If zero, kernel cache is completely disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6291e47775d9059cdfe1dda017624dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6291e47775d9059cdfe1dda017624dbb">&#9670;&nbsp;</a></span>setKernelProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setKernelProfiling </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggles profiling of kernel runs inside the tuner. Profiled kernel runs generate profiling counters which can be used by searchers and stop conditions for more accurate performance measurement. Profiling counters can also be retrieved through API and printed into CSV file with tuning results. Note that enabling profiling will result in longer tuning times because profiled kernels have to be launched multiple times with the same configuration in order to collect all profiling counters. Asynchronous kernel launches are currently not supported when kernel profiling is enabled. Kernel profiling is disabled by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If true, kernel profiling is enabled. It is disabled otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f722474ac405d70d579e707fe80caa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f722474ac405d70d579e707fe80caa5">&#9670;&nbsp;</a></span>setKernelProfilingCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setKernelProfilingCounters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>counterNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies profiling counters that will be collected during kernel profiling. Note that not all profiling counters are available on all devices.</p>
<p>For the list of CUDA CUPTI profiling counters, see: <a href="https://docs.nvidia.com/cuda/cupti/index.html#metrics-reference">https://docs.nvidia.com/cuda/cupti/index.html#metrics-reference</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counterNames</td><td>Names of counters that will be collected during kernel profiling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a571ef8d31c049dae3b3e132cf293f23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571ef8d31c049dae3b3e132cf293f23e">&#9670;&nbsp;</a></span>setLocalMemoryModifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setLocalMemoryModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>argumentId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>modifierFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a local memory modifier function for specified kernel. This function receives size of specified local memory argument and values of specified kernel parameters as input and returns modified argument size based on these values. The modifiers are useful in case when kernel parameters affect the size of local memory arguments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the modifier will be set. </td></tr>
    <tr><td class="paramname">argumentId</td><td>Id of local memory kernel argument which will be affected by the modifier. </td></tr>
    <tr><td class="paramname">parameterNames</td><td>Names of kernel parameters whose values will be passed into the modifier function. The order of parameter names corresponds to the order of parameter values inside the modifier function vector argument. </td></tr>
    <tr><td class="paramname">modifierFunction</td><td>Function which receives size of specified local memory argument and values of specified kernel parameters as input and returns modified argument size based on these values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c79c9e759300cfa89071ecbf8625351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c79c9e759300cfa89071ecbf8625351">&#9670;&nbsp;</a></span>setLoggingLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::setLoggingLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a17afdb449e82292a32fba46ff7a54781">LoggingLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets logging level for tuner. Default logging level is info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Logging level which will be used by tuner. See <a class="el" href="namespacektt.html#a17afdb449e82292a32fba46ff7a54781">LoggingLevel</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3e0133a7e9ff598922468648cdaaa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e0133a7e9ff598922468648cdaaa66">&#9670;&nbsp;</a></span>setLoggingTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::setLoggingTarget </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outputTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the target for info messages logging to specified output stream. Default logging target is <code>std::clog</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputTarget</td><td>Location where tuner info messages will be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada578ea479190ebcbadef6873cd44092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada578ea479190ebcbadef6873cd44092">&#9670;&nbsp;</a></span>setLoggingTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ktt::Tuner::setLoggingTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the target for info messages logging to specified file. Default logging target is <code>std::clog</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to file where tuner info messages will printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad679eb4f58e26571bf8d88086fec8f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad679eb4f58e26571bf8d88086fec8f47">&#9670;&nbsp;</a></span>setPrintingTimeUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setPrintingTimeUnit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a161b9af8714615ef2c1770b020ce1511">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets time unit used for printing of results. Default time unit is milliseconds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>Time unit which will be used for printing of results. See <a class="el" href="namespacektt.html#a161b9af8714615ef2c1770b020ce1511">TimeUnit</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84062246cb9d65e816ed70965fa4d499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84062246cb9d65e816ed70965fa4d499">&#9670;&nbsp;</a></span>setReferenceClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setReferenceClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classktt_1_1_reference_class.html">ReferenceClass</a> &gt;&#160;</td>
          <td class="paramname"><em>referenceClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>validatedArgumentIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets reference class for specified kernel. Reference class output will be compared to tuned kernel output in order to ensure correctness of computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which reference class will be set. </td></tr>
    <tr><td class="paramname">referenceClass</td><td>Reference class which produces reference output for specified kernel. See <a class="el" href="classktt_1_1_reference_class.html">ReferenceClass</a> for more information. </td></tr>
    <tr><td class="paramname">validatedArgumentIds</td><td>Ids of kernel arguments which will be validated. The validated arguments must be vector arguments and cannot be read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaebd071678533e08b361ee6e40bbc96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebd071678533e08b361ee6e40bbc96e">&#9670;&nbsp;</a></span>setReferenceKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setReferenceKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>referenceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>referenceConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>validatedArgumentIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets reference kernel for specified kernel. Reference kernel output will be compared to tuned kernel output in order to ensure correctness of computation. Reference kernel uses only single configuration and cannot be composite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which reference kernel will be set. </td></tr>
    <tr><td class="paramname">referenceId</td><td>Id of reference kernel. This can be the same as validated kernel. This can be useful if the kernel has a configuration which is known to produce correct results. </td></tr>
    <tr><td class="paramname">referenceConfiguration</td><td>Configuration under which the reference kernel will be launched to produce reference output. </td></tr>
    <tr><td class="paramname">validatedArgumentIds</td><td>Ids of kernel arguments which will be validated. The validated arguments must be vector arguments and cannot be read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdd2201bd0031520e6bc520a827ec74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd2201bd0031520e6bc520a827ec74f">&#9670;&nbsp;</a></span>setSearchMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setSearchMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a5f5b49f1e11331a499aa44fb1fa6788b">SearchMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies search method which will be used during kernel tuning. Number of required search arguments depends on the search method. Default search method is full search. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Search method which will be used during kernel tuning. See SearchMethod for more information. </td></tr>
    <tr><td class="paramname">arguments</td><td>Arguments necessary for specified search method to work. Following arguments are required for corresponding search method, the order of arguments is important:<ul>
<li>FullSearch - none</li>
<li>RandomSearch - none</li>
<li>Annealing - maximum temperature</li>
<li>MCMC - none </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb4ecdde64d7bb80759fa446cd0dff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb4ecdde64d7bb80759fa446cd0dff1">&#9670;&nbsp;</a></span>setThreadModifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setThreadModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a>&#160;</td>
          <td class="paramname"><em>modifierType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a>&#160;</td>
          <td class="paramname"><em>modifierDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(const size_t, const std::vector&lt; size_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>modifierFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a thread modifier function for specified kernel. This function receives thread size in specified kernel dimension and values of specified kernel parameters as input and returns modified thread size based on these values. The modifiers are useful in case when kernel parameters affect the number of required kernel threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the modifier will be set. </td></tr>
    <tr><td class="paramname">modifierType</td><td>Type of the thread modifier. See <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> for more information. </td></tr>
    <tr><td class="paramname">modifierDimension</td><td>Dimension which will be affected by the modifier. See <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> for more information. </td></tr>
    <tr><td class="paramname">parameterNames</td><td>Names of kernel parameters whose values will be passed into the modifier function. The order of parameter names corresponds to the order of parameter values inside the modifier function vector argument. </td></tr>
    <tr><td class="paramname">modifierFunction</td><td>Function which receives thread size in specified kernel dimension and values of specified kernel parameters as input and returns modified thread size based on these values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72f6b2785bfa64b659914525916acfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f6b2785bfa64b659914525916acfef">&#9670;&nbsp;</a></span>setThreadModifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setThreadModifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a>&#160;</td>
          <td class="paramname"><em>modifierType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a>&#160;</td>
          <td class="paramname"><em>modifierDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a>&#160;</td>
          <td class="paramname"><em>modifierAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a thread modifier for specified kernel. This is a simplified version of the thread modifier method which only supports one parameter and limited number of actions, but is easier to use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the modifier will be set. </td></tr>
    <tr><td class="paramname">modifierType</td><td>Type of the thread modifier. See <a class="el" href="namespacektt.html#ac5bc0a65f097bc3326d6497c0f3877b0">ModifierType</a> for more information. </td></tr>
    <tr><td class="paramname">modifierDimension</td><td>Dimension which will be affected by the thread modifier. See <a class="el" href="namespacektt.html#a47158e719571f19776b1dc4a1183eb39">ModifierDimension</a> for more information. </td></tr>
    <tr><td class="paramname">parameterName</td><td>Name of a kernel parameter whose value will be utilized by the thread modifier. </td></tr>
    <tr><td class="paramname">modifierAction</td><td>Action of the thread modifier. See <a class="el" href="namespacektt.html#aa22e627ca88d7d508cd228c977bf4dd8">ModifierAction</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2def6687ce5048047786008a819a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2def6687ce5048047786008a819a2d2">&#9670;&nbsp;</a></span>setTuningManipulator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setTuningManipulator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a> &gt;&#160;</td>
          <td class="paramname"><em>manipulator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets tuning manipulator for specified kernel. Tuning manipulator enables customization of kernel execution. This is useful in several cases, eg. running part of the computation in C++ code, utilizing iterative kernel launches or composite kernels. See <a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning manipulator will be set. </td></tr>
    <tr><td class="paramname">manipulator</td><td>Tuning manipulator for specified kernel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa72e9d52720d83fc8622920536df15d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72e9d52720d83fc8622920536df15d7">&#9670;&nbsp;</a></span>setTuningManipulatorSynchronization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setTuningManipulatorSynchronization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls whether framework performs implicit device synchronization after launchComputation() method inside tuning manipulator has finished. Performing the synchronization is necessary for obtaining correct computation duration. Turning it off may increase performance during regular computation after the tuning has concluded. Synchronization is turned on by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning manipulator synchronization flag will be set. </td></tr>
    <tr><td class="paramname">flag</td><td>If true, tuning manipulator synchronization will be turned on for specified kernel or kernel composition. It will be turned off otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4562a0fbc7a0b9154225ff6697f09f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4562a0fbc7a0b9154225ff6697f09f5">&#9670;&nbsp;</a></span>setValidationMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setValidationMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a187d4987bb48bc1f78f628c8aa840a20">ValidationMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>toleranceThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets validation method and tolerance threshold for floating-point argument validation. Default validation method is side by side comparison. Default tolerance threshold is 1e-4. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Validation method which will be used for floating-point argument validation. See <a class="el" href="namespacektt.html#a187d4987bb48bc1f78f628c8aa840a20">ValidationMethod</a> for more information. </td></tr>
    <tr><td class="paramname">toleranceThreshold</td><td>Output validation threshold. If difference between tuned kernel output and reference output is within tolerance threshold, the tuned kernel output will be considered correct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa648b6c2492c4f13c13a7fcae2a02c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa648b6c2492c4f13c13a7fcae2a02c92">&#9670;&nbsp;</a></span>setValidationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setValidationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a3baf318a03750f7418a5faa051967c04">ValidationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets modes under which kernel output validation is enabled. By default, output validation is enabled only during kernel tuning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Bitfield of modes under which kernel output validation is enabled. See <a class="el" href="namespacektt.html#a3baf318a03750f7418a5faa051967c04">ValidationMode</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70e9d2eb698f8ae84f8f6c98f137c246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e9d2eb698f8ae84f8f6c98f137c246">&#9670;&nbsp;</a></span>setValidationRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::Tuner::setValidationRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets validation range for specified argument to specified validation range. Only elements within validation range, starting with the first element, will be validated. All elements are validated by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the validation range will be set. </td></tr>
    <tr><td class="paramname">range</td><td>Range inside which the argument elements will be validated, starting from the first element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15e5fc88cd393aea02eb9f7b099c6109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e5fc88cd393aea02eb9f7b099c6109">&#9670;&nbsp;</a></span>tuneKernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> &gt; ktt::Tuner::tuneKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the tuning process for specified kernel. Creates configuration space based on combinations of provided kernel parameters and constraints. The configurations will be launched in order that depends on specified <a class="el" href="namespacektt.html#a5f5b49f1e11331a499aa44fb1fa6788b">SearchMethod</a>. Tuning will end when all configurations are explored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning will start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of objects containing information about computation using tested kernel configurations. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<a id="aa44ca3e81c04c5278e1b3ede95c39201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44ca3e81c04c5278e1b3ede95c39201">&#9670;&nbsp;</a></span>tuneKernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> &gt; ktt::Tuner::tuneKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classktt_1_1_stop_condition.html">StopCondition</a> &gt;&#160;</td>
          <td class="paramname"><em>stopCondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the tuning process for specified kernel. Creates configuration space based on combinations of provided kernel parameters and constraints. The configurations will be launched in order that depends on specified <a class="el" href="namespacektt.html#a5f5b49f1e11331a499aa44fb1fa6788b">SearchMethod</a>. Tuning will end either when all configurations are explored or when specified stop condition is met. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning will start. </td></tr>
    <tr><td class="paramname">stopCondition</td><td>Stop condition which decides whether to continue the tuning process. See <a class="el" href="classktt_1_1_stop_condition.html">StopCondition</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of objects containing information about computation using tested kernel configurations. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<a id="ae5c62e9e550a857082facfd9d129eaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c62e9e550a857082facfd9d129eaa5">&#9670;&nbsp;</a></span>tuneKernelByStep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> ktt::Tuner::tuneKernelByStep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs one step of the tuning process for specified kernel. When this method is called inside tuner for the first time, it creates configuration space based on combinations of provided kernel parameters and constraints. Each time this method is called, it launches single kernel configuration. If all configurations were already tested, runs kernel using the best configuration. Output data can be retrieved by providing output descriptors. Always performs recomputation of reference output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning by step will start. </td></tr>
    <tr><td class="paramname">output</td><td>User-provided memory locations for kernel arguments which should be retrieved. See <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing information about computation using current kernel configuration. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<a id="a040a0a5e8a7dac656ab8eadcb727cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040a0a5e8a7dac656ab8eadcb727cd16">&#9670;&nbsp;</a></span>tuneKernelByStep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> ktt::Tuner::tuneKernelByStep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recomputeReference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs one step of the tuning process for specified kernel. When this method is called inside tuner for the first time, it creates configuration space based on combinations of provided kernel parameters and constraints. Each time this method is called, it launches single kernel configuration. If all configurations were already tested, runs kernel using the best configuration. Output data can be retrieved by providing output descriptors. Allows control over recomputation of reference output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the tuning by step will start. </td></tr>
    <tr><td class="paramname">output</td><td>User-provided memory locations for kernel arguments which should be retrieved. See <a class="el" href="classktt_1_1_output_descriptor.html">OutputDescriptor</a> for more information. </td></tr>
    <tr><td class="paramname">recomputeReference</td><td>Flag which controls whether recomputation of reference output should be performed or not. Useful if kernel data between individual method invocations sometimes change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing information about computation using current kernel configuration. See <a class="el" href="classktt_1_1_computation_result.html">ComputationResult</a> for more information. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/<a class="el" href="tuner__api_8h_source.html">tuner_api.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacektt.html">ktt</a></li><li class="navelem"><a class="el" href="classktt_1_1_tuner.html">Tuner</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
