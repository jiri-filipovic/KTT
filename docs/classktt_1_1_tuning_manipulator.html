<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kernel Tuning Toolkit: ktt::TuningManipulator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kernel Tuning Toolkit
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classktt_1_1_tuning_manipulator.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classktt_1_1_tuning_manipulator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ktt::TuningManipulator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tuning__manipulator_8h_source.html">tuning_manipulator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9399d7fee67bf85ee73aedd3e8ba6201"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a9399d7fee67bf85ee73aedd3e8ba6201">~TuningManipulator</a> ()</td></tr>
<tr class="separator:a9399d7fee67bf85ee73aedd3e8ba6201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c993600def90f0e5e67c7a03fcdd0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#aa5c993600def90f0e5e67c7a03fcdd0d">launchComputation</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)=0</td></tr>
<tr class="separator:aa5c993600def90f0e5e67c7a03fcdd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc5ff3885beade6c4aca1319134a553"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#aacc5ff3885beade6c4aca1319134a553">enableArgumentPreload</a> () const</td></tr>
<tr class="separator:aacc5ff3885beade6c4aca1319134a553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991ebd21b3261d60146528e12725f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a0991ebd21b3261d60146528e12725f80">runKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)</td></tr>
<tr class="separator:a0991ebd21b3261d60146528e12725f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777ea45abef954f2b1fe02f5bac3a619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a777ea45abef954f2b1fe02f5bac3a619">runKernelAsync</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a777ea45abef954f2b1fe02f5bac3a619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d04a12e5001112ba611b6fe44ea61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a62d04a12e5001112ba611b6fe44ea61c">runKernel</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)</td></tr>
<tr class="separator:a62d04a12e5001112ba611b6fe44ea61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095e5d558ba3b1871c3a7ef4d816279c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a095e5d558ba3b1871c3a7ef4d816279c">runKernelAsync</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a095e5d558ba3b1871c3a7ef4d816279c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da38c2570ff8daacf443869e0ca4515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a3da38c2570ff8daacf443869e0ca4515">runKernelWithProfiling</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id)</td></tr>
<tr class="separator:a3da38c2570ff8daacf443869e0ca4515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fb08be4b0aa70cff3112df24a9c097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a75fb08be4b0aa70cff3112df24a9c097">runKernelWithProfiling</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;globalSize, const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;localSize)</td></tr>
<tr class="separator:a75fb08be4b0aa70cff3112df24a9c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5d0dc24d00450a0c7558b588e2e57e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a4d5d0dc24d00450a0c7558b588e2e57e">getRemainingKernelProfilingRuns</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id) const</td></tr>
<tr class="separator:a4d5d0dc24d00450a0c7558b588e2e57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a20b1dd6056d5a3937c92b07ec6c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a04a20b1dd6056d5a3937c92b07ec6c13">getDefaultDeviceQueue</a> () const</td></tr>
<tr class="separator:a04a20b1dd6056d5a3937c92b07ec6c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e796aed2c163e56de10ac10e000538"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ab9e796aed2c163e56de10ac10e000538">getAllDeviceQueues</a> () const</td></tr>
<tr class="separator:ab9e796aed2c163e56de10ac10e000538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c5118126dab154ce60c01127ae5991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a90c5118126dab154ce60c01127ae5991">synchronizeQueue</a> (const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a90c5118126dab154ce60c01127ae5991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fa2dec12d516dd18befebf5c003e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a64fa2dec12d516dd18befebf5c003e68">synchronizeDevice</a> ()</td></tr>
<tr class="separator:a64fa2dec12d516dd18befebf5c003e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751db1d4f8cf1c00925dfefa57aaa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a3751db1d4f8cf1c00925dfefa57aaa27">getCurrentGlobalSize</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id) const</td></tr>
<tr class="separator:a3751db1d4f8cf1c00925dfefa57aaa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae57cd60a640856f881af97ee998b0e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#aae57cd60a640856f881af97ee998b0e7">getCurrentLocalSize</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id) const</td></tr>
<tr class="separator:aae57cd60a640856f881af97ee998b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45cfd0518582e9e7c289e0e8d414d5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ac45cfd0518582e9e7c289e0e8d414d5c">getCurrentConfiguration</a> () const</td></tr>
<tr class="separator:ac45cfd0518582e9e7c289e0e8d414d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449df2809792e030439be9d70a8c07e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a449df2809792e030439be9d70a8c07e6">updateArgumentScalar</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *argumentData)</td></tr>
<tr class="separator:a449df2809792e030439be9d70a8c07e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e307646f17f2861d8c981308cd2221c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a1e307646f17f2861d8c981308cd2221c">updateArgumentLocal</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const size_t numberOfElements)</td></tr>
<tr class="separator:a1e307646f17f2861d8c981308cd2221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872a3865330f2a15282facd6392ccdcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a872a3865330f2a15282facd6392ccdcd">updateArgumentVector</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *argumentData)</td></tr>
<tr class="separator:a872a3865330f2a15282facd6392ccdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89071adbe2f15811935caa5613ea4c14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a89071adbe2f15811935caa5613ea4c14">updateArgumentVectorAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *argumentData, <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a89071adbe2f15811935caa5613ea4c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996d65fb5ee74bf5dc71551f678026d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ae996d65fb5ee74bf5dc71551f678026d">updateArgumentVector</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *argumentData, const size_t numberOfElements)</td></tr>
<tr class="separator:ae996d65fb5ee74bf5dc71551f678026d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f850b561d79021d1613beb35b786b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a8f850b561d79021d1613beb35b786b0b">updateArgumentVectorAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const void *argumentData, const size_t numberOfElements, <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a8f850b561d79021d1613beb35b786b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aa79df2a16b5d5fafa5e0576871e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ad7aa79df2a16b5d5fafa5e0576871e9c">getArgumentVector</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, void *destination) const</td></tr>
<tr class="separator:ad7aa79df2a16b5d5fafa5e0576871e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2209f1bd5dafde789250faa5d2bd8436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a2209f1bd5dafde789250faa5d2bd8436">getArgumentVectorAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, void *destination, <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue) const</td></tr>
<tr class="separator:a2209f1bd5dafde789250faa5d2bd8436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde17d134f818894449dab865776eff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#abde17d134f818894449dab865776eff5">getArgumentVector</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, void *destination, const size_t numberOfElements) const</td></tr>
<tr class="separator:abde17d134f818894449dab865776eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c86deb31ca9c666a2ed8c0c719937e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a7c86deb31ca9c666a2ed8c0c719937e0">getArgumentVectorAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, void *destination, const size_t numberOfElements, <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue) const</td></tr>
<tr class="separator:a7c86deb31ca9c666a2ed8c0c719937e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4872415bede52fd40f969df0f6f3d6f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a4872415bede52fd40f969df0f6f3d6f8">copyArgumentVector</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> destination, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> source, const size_t numberOfElements)</td></tr>
<tr class="separator:a4872415bede52fd40f969df0f6f3d6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d26b9fde986eaed59dfb89fd94f9a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a76d26b9fde986eaed59dfb89fd94f9a4">copyArgumentVectorAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> destination, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> source, const size_t numberOfElements, const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a76d26b9fde986eaed59dfb89fd94f9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88cabca2a372c0366d9b077ad812f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ab88cabca2a372c0366d9b077ad812f02">resizeArgumentVector</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, const size_t newNumberOfElements, const bool preserveOldData)</td></tr>
<tr class="separator:ab88cabca2a372c0366d9b077ad812f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fddd6526a875a337193ab0d6b465567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a8fddd6526a875a337193ab0d6b465567">changeKernelArguments</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;argumentIds)</td></tr>
<tr class="separator:a8fddd6526a875a337193ab0d6b465567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3435ca6b5420a370a0de4c324feb9903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a3435ca6b5420a370a0de4c324feb9903">swapKernelArguments</a> (const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a> id, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> argumentIdFirst, const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> argumentIdSecond)</td></tr>
<tr class="separator:a3435ca6b5420a370a0de4c324feb9903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79313db2ca9cca7e158716293558ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ae79313db2ca9cca7e158716293558ffd">createArgumentBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id)</td></tr>
<tr class="separator:ae79313db2ca9cca7e158716293558ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e7b8fe960b2a9cc942205eb1928085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a63e7b8fe960b2a9cc942205eb1928085">createArgumentBufferAsync</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id, <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> queue)</td></tr>
<tr class="separator:a63e7b8fe960b2a9cc942205eb1928085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f9d73e032b7014ada30c8b336e6c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ab4f9d73e032b7014ada30c8b336e6c0a">destroyArgumentBuffer</a> (const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> id)</td></tr>
<tr class="separator:ab4f9d73e032b7014ada30c8b336e6c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a61f92883b4ea8c735c91081a70a506b2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#a61f92883b4ea8c735c91081a70a506b2">getParameterValue</a> (const std::string &amp;parameterName, const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;parameterPairs)</td></tr>
<tr class="separator:a61f92883b4ea8c735c91081a70a506b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac944ad0bc678cd2e7092fd3ad1b5d41d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classktt_1_1_tuning_manipulator.html#ac944ad0bc678cd2e7092fd3ad1b5d41d">getParameterValueDouble</a> (const std::string &amp;parameterName, const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;parameterPairs)</td></tr>
<tr class="separator:ac944ad0bc678cd2e7092fd3ad1b5d41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5fd9e42d3b3fa0e8432fd9814695fb3a"><td class="memItemLeft" align="right" valign="top"><a id="a5fd9e42d3b3fa0e8432fd9814695fb3a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>KernelRunner</b></td></tr>
<tr class="separator:a5fd9e42d3b3fa0e8432fd9814695fb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which can be used to customize kernel launch in order to run some part of computation on CPU, utilize iterative kernel launches, kernel compositions and more. In order to use this functionality, new class which publicly inherits from tuning manipulator class has to be defined. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9399d7fee67bf85ee73aedd3e8ba6201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9399d7fee67bf85ee73aedd3e8ba6201">&#9670;&nbsp;</a></span>~TuningManipulator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ktt::TuningManipulator::~TuningManipulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tuning manipulator destructor. Inheriting class can override destructor with custom implementation. Default implementation is provided by KTT framework. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8fddd6526a875a337193ab0d6b465567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fddd6526a875a337193ab0d6b465567">&#9670;&nbsp;</a></span>changeKernelArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::changeKernelArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argumentIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes kernel arguments for specified kernel by providing corresponding argument ids. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the arguments will be changed. </td></tr>
    <tr><td class="paramname">argumentIds</td><td>Ids of arguments to be used by specified kernel. Order of ids must match the order of kernel arguments specified in kernel function. Argument ids for single kernel must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4872415bede52fd40f969df0f6f3d6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4872415bede52fd40f969df0f6f3d6f8">&#9670;&nbsp;</a></span>copyArgumentVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::copyArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies part of source vector argument to destination vector argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Id of destination vector argument. </td></tr>
    <tr><td class="paramname">source</td><td>Id of source vector argument. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of elements which will be copied to destination argument, starting with first element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76d26b9fde986eaed59dfb89fd94f9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d26b9fde986eaed59dfb89fd94f9a4">&#9670;&nbsp;</a></span>copyArgumentVectorAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::copyArgumentVectorAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies part of source vector argument to destination vector argument. Argument will be copied asynchronously in specified queue. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Id of destination vector argument. </td></tr>
    <tr><td class="paramname">source</td><td>Id of source vector argument. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of elements which will be copied to destination argument, starting with first element. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to copy argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae79313db2ca9cca7e158716293558ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79313db2ca9cca7e158716293558ffd">&#9670;&nbsp;</a></span>createArgumentBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::createArgumentBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfers specified kernel argument to a buffer from which it can be accessed by compute API. This method should be utilized only if argument preload is disabled. See <a class="el" href="classktt_1_1_tuning_manipulator.html#aacc5ff3885beade6c4aca1319134a553">enableArgumentPreload()</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the buffer will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e7b8fe960b2a9cc942205eb1928085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e7b8fe960b2a9cc942205eb1928085">&#9670;&nbsp;</a></span>createArgumentBufferAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::createArgumentBufferAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfers specified kernel argument to a buffer from which it can be accessed by compute API. This method should be utilized only if argument preload is disabled. See <a class="el" href="classktt_1_1_tuning_manipulator.html#aacc5ff3885beade6c4aca1319134a553">enableArgumentPreload()</a> for more information. Argument will be transferred asynchronously in specified queue. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the buffer will be created. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to transfer argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4f9d73e032b7014ada30c8b336e6c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f9d73e032b7014ada30c8b336e6c0a">&#9670;&nbsp;</a></span>destroyArgumentBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::destroyArgumentBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys compute API buffer for specified kernel argument. This method should be utilized only if argument preload is disabled. See <a class="el" href="classktt_1_1_tuning_manipulator.html#aacc5ff3885beade6c4aca1319134a553">enableArgumentPreload()</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of argument for which the buffer will be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc5ff3885beade6c4aca1319134a553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc5ff3885beade6c4aca1319134a553">&#9670;&nbsp;</a></span>enableArgumentPreload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ktt::TuningManipulator::enableArgumentPreload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls whether arguments for all kernels that are part of manipulator will be automatically uploaded to corresponding compute API buffers before any kernel is run in the current invocation of <a class="el" href="classktt_1_1_tuning_manipulator.html#aa5c993600def90f0e5e67c7a03fcdd0d">launchComputation()</a> method. Argument preload is turned on by default.</p>
<p>Turning this behavior off is useful during utilization of kernel compositions where different kernels use different arguments which would not all fit into available memory at once. Buffer creation and deletion can be then controlled by using <a class="el" href="classktt_1_1_tuning_manipulator.html#ae79313db2ca9cca7e158716293558ffd">createArgumentBuffer()</a> and <a class="el" href="classktt_1_1_tuning_manipulator.html#ab4f9d73e032b7014ada30c8b336e6c0a">destroyArgumentBuffer()</a> methods for corresponding arguments. Any leftover arguments after <a class="el" href="classktt_1_1_tuning_manipulator.html#aa5c993600def90f0e5e67c7a03fcdd0d">launchComputation()</a> method has finished will still be automatically cleaned up. Inheriting class can override this method. </p><dl class="section return"><dt>Returns</dt><dd>Flag which controls whether the argument preload is enabled or not. </dd></dl>

</div>
</div>
<a id="ab9e796aed2c163e56de10ac10e000538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e796aed2c163e56de10ac10e000538">&#9670;&nbsp;</a></span>getAllDeviceQueues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> &gt; ktt::TuningManipulator::getAllDeviceQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves ids of all available device queues. Number of available device queues can be specified during tuner creation. </p><dl class="section return"><dt>Returns</dt><dd>Ids of all available device queues. </dd></dl>

</div>
</div>
<a id="ad7aa79df2a16b5d5fafa5e0576871e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aa79df2a16b5d5fafa5e0576871e9c">&#9670;&nbsp;</a></span>getArgumentVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::getArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves specified vector argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be retrieved. </td></tr>
    <tr><td class="paramname">destination</td><td>Pointer to destination where vector argument data will be copied. Destination buffer size needs to be equal or greater than argument size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abde17d134f818894449dab865776eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde17d134f818894449dab865776eff5">&#9670;&nbsp;</a></span>getArgumentVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::getArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves part of specified vector argument. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be retrieved. </td></tr>
    <tr><td class="paramname">destination</td><td>Pointer to destination where vector argument data will be copied. Destination buffer size needs to be equal or greater than size of specified number of elements. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of elements which will be copied to specified destination, starting with first element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2209f1bd5dafde789250faa5d2bd8436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2209f1bd5dafde789250faa5d2bd8436">&#9670;&nbsp;</a></span>getArgumentVectorAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::getArgumentVectorAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves specified vector argument. Argument will be retrieved asynchronously in specified queue. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be retrieved. </td></tr>
    <tr><td class="paramname">destination</td><td>Pointer to destination where vector argument data will be copied. Destination buffer size needs to be equal or greater than argument size. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to retrieve argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c86deb31ca9c666a2ed8c0c719937e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c86deb31ca9c666a2ed8c0c719937e0">&#9670;&nbsp;</a></span>getArgumentVectorAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::getArgumentVectorAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves part of specified vector argument. Argument will be retrieved asynchronously in specified queue. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be retrieved. </td></tr>
    <tr><td class="paramname">destination</td><td>Pointer to destination where vector argument data will be copied. Destination buffer size needs to be equal or greater than size of specified number of elements. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of elements which will be copied to specified destination, starting with first element. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to retrieve argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac45cfd0518582e9e7c289e0e8d414d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45cfd0518582e9e7c289e0e8d414d5c">&#9670;&nbsp;</a></span>getCurrentConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; ktt::TuningManipulator::getCurrentConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns configuration used inside current invocation of <a class="el" href="classktt_1_1_tuning_manipulator.html#aa5c993600def90f0e5e67c7a03fcdd0d">launchComputation()</a> method. </p><dl class="section return"><dt>Returns</dt><dd>Current configuration. See <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> for more information. </dd></dl>

</div>
</div>
<a id="a3751db1d4f8cf1c00925dfefa57aaa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3751db1d4f8cf1c00925dfefa57aaa27">&#9670;&nbsp;</a></span>getCurrentGlobalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> ktt::TuningManipulator::getCurrentGlobalSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns global thread size of specified kernel based on the current configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the global size will be retrieved. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global thread size of specified kernel. </dd></dl>

</div>
</div>
<a id="aae57cd60a640856f881af97ee998b0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae57cd60a640856f881af97ee998b0e7">&#9670;&nbsp;</a></span>getCurrentLocalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> ktt::TuningManipulator::getCurrentLocalSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns local thread size of specified kernel based on the current configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the local size will be retrieved. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Local thread size of specified kernel. </dd></dl>

</div>
</div>
<a id="a04a20b1dd6056d5a3937c92b07ec6c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a20b1dd6056d5a3937c92b07ec6c13">&#9670;&nbsp;</a></span>getDefaultDeviceQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a> ktt::TuningManipulator::getDefaultDeviceQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves id of device queue to which all synchronous commands are submitted. </p><dl class="section return"><dt>Returns</dt><dd>Id of device queue to which all synchronous commands are submitted. </dd></dl>

</div>
</div>
<a id="a61f92883b4ea8c735c91081a70a506b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f92883b4ea8c735c91081a70a506b2">&#9670;&nbsp;</a></span>getParameterValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t ktt::TuningManipulator::getParameterValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns integer value of specified parameter from provided vector of parameters. </p><dl class="section return"><dt>Returns</dt><dd>Integer value of specified parameter. </dd></dl>

</div>
</div>
<a id="ac944ad0bc678cd2e7092fd3ad1b5d41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac944ad0bc678cd2e7092fd3ad1b5d41d">&#9670;&nbsp;</a></span>getParameterValueDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ktt::TuningManipulator::getParameterValueDouble </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classktt_1_1_parameter_pair.html">ParameterPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns floating-point value of specified parameter from provided vector of parameters. </p><dl class="section return"><dt>Returns</dt><dd>Floating-point value of specified parameter. </dd></dl>

</div>
</div>
<a id="a4d5d0dc24d00450a0c7558b588e2e57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5d0dc24d00450a0c7558b588e2e57e">&#9670;&nbsp;</a></span>getRemainingKernelProfilingRuns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ktt::TuningManipulator::getRemainingKernelProfilingRuns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves number of remaining profiling runs that are needed to collect all the profiling counters for specified kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the number of remaining profiling runs will be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c993600def90f0e5e67c7a03fcdd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c993600def90f0e5e67c7a03fcdd0d">&#9670;&nbsp;</a></span>launchComputation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::launchComputation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is responsible for directly running the computation and ensuring that correct results are computed. It may utilize any other method inside the tuning manipulator as well as any user-defined methods. Any other tuning manipulator methods run from this method only affect current invocation of <a class="el" href="classktt_1_1_tuning_manipulator.html#aa5c993600def90f0e5e67c7a03fcdd0d">launchComputation()</a> method. Inheriting class must provide implementation for this method.</p>
<p>When tuning manipulator is used, computation duration is calculated based on duration of <a class="el" href="classktt_1_1_tuning_manipulator.html#aa5c993600def90f0e5e67c7a03fcdd0d">launchComputation()</a> method. Initial buffer transfer times are not included in this duration (eg. duration of <a class="el" href="classktt_1_1_tuning_manipulator.html#ae79313db2ca9cca7e158716293558ffd">createArgumentBuffer()</a> methods). KTT framework overhead and kernel compilation times are not included in the final duration either. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of a kernel or a kernel composition which will be used to launch kernel from tuner API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab88cabca2a372c0366d9b077ad812f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88cabca2a372c0366d9b077ad812f02">&#9670;&nbsp;</a></span>resizeArgumentVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::resizeArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newNumberOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserveOldData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes specified vector argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be resized. </td></tr>
    <tr><td class="paramname">newNumberOfElements</td><td>Number of elements inside resized vector argument. </td></tr>
    <tr><td class="paramname">preserveOldData</td><td>If true, data from old buffer will be copied into resized buffer. If false, the old data will be discarded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0991ebd21b3261d60146528e12725f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0991ebd21b3261d60146528e12725f80">&#9670;&nbsp;</a></span>runKernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::runKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs kernel with specified id using thread sizes based on the current configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62d04a12e5001112ba611b6fe44ea61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d04a12e5001112ba611b6fe44ea61c">&#9670;&nbsp;</a></span>runKernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::runKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs kernel with specified id using specified thread sizes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for global size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for local size with which the kernel will be run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a777ea45abef954f2b1fe02f5bac3a619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777ea45abef954f2b1fe02f5bac3a619">&#9670;&nbsp;</a></span>runKernelAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::runKernelAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs kernel with specified id using thread sizes based on the current configuration. Kernel will be launched asynchronously in specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to run kernel will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a095e5d558ba3b1871c3a7ef4d816279c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095e5d558ba3b1871c3a7ef4d816279c">&#9670;&nbsp;</a></span>runKernelAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::runKernelAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs kernel with specified id using specified thread sizes. Kernel will be launched asynchronously in specified queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for global size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for local size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to run kernel will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3da38c2570ff8daacf443869e0ca4515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da38c2570ff8daacf443869e0ca4515">&#9670;&nbsp;</a></span>runKernelWithProfiling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::runKernelWithProfiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs kernel with specified id using thread sizes based on the current configuration. Collection of profiling counters will be enabled for this kernel run which means the performance will be decreased. Running a kernel with profiling will currently always cause implicit device synchronization before and after the kernel run has finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75fb08be4b0aa70cff3112df24a9c097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fb08be4b0aa70cff3112df24a9c097">&#9670;&nbsp;</a></span>runKernelWithProfiling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::runKernelWithProfiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classktt_1_1_dimension_vector.html">DimensionVector</a> &amp;&#160;</td>
          <td class="paramname"><em>localSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs kernel with specified id using specified thread sizes. Collection of profiling counters will be enabled for this kernel run which means the performance will be decreased. Running a kernel with profiling will currently always cause implicit device synchronization before and after the kernel run has finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel which will be run. It must either match the id used to launch kernel from tuner API or be included inside composition which was launched from tuner API. </td></tr>
    <tr><td class="paramname">globalSize</td><td>Dimensions for global size with which the kernel will be run. </td></tr>
    <tr><td class="paramname">localSize</td><td>Dimensions for local size with which the kernel will be run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3435ca6b5420a370a0de4c324feb9903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3435ca6b5420a370a0de4c324feb9903">&#9670;&nbsp;</a></span>swapKernelArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::swapKernelArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a47b4d6f1468a13007692b8bd5dbe42ba">KernelId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>argumentIdFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>argumentIdSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps positions of existing kernel arguments for specified kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of kernel for which the arguments will be swapped. </td></tr>
    <tr><td class="paramname">argumentIdFirst</td><td>Id of the first argument which will be swapped. </td></tr>
    <tr><td class="paramname">argumentIdSecond</td><td>Id of the second argument which will be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64fa2dec12d516dd18befebf5c003e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fa2dec12d516dd18befebf5c003e68">&#9670;&nbsp;</a></span>synchronizeDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::synchronizeDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until all commands submitted to all device queues are completed. </p>

</div>
</div>
<a id="a90c5118126dab154ce60c01127ae5991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c5118126dab154ce60c01127ae5991">&#9670;&nbsp;</a></span>synchronizeQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::synchronizeQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until all commands submitted to specified device queue are completed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Id of queue which will be synchronized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e307646f17f2861d8c981308cd2221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e307646f17f2861d8c981308cd2221c">&#9670;&nbsp;</a></span>updateArgumentLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::updateArgumentLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates specified local memory argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of local memory argument which will be updated. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of local memory elements inside updated argument. Data types for old and new data match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a449df2809792e030439be9d70a8c07e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449df2809792e030439be9d70a8c07e6">&#9670;&nbsp;</a></span>updateArgumentScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::updateArgumentScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>argumentData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates specified scalar argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of scalar argument which will be updated. </td></tr>
    <tr><td class="paramname">argumentData</td><td>Pointer to new data for scalar argument. Data types for old and new data have to match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a872a3865330f2a15282facd6392ccdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872a3865330f2a15282facd6392ccdcd">&#9670;&nbsp;</a></span>updateArgumentVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::updateArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>argumentData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates specified vector argument. Does not modify argument size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be updated. </td></tr>
    <tr><td class="paramname">argumentData</td><td>Pointer to new data for vector argument. Number of elements and data types for old and new data have to match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae996d65fb5ee74bf5dc71551f678026d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae996d65fb5ee74bf5dc71551f678026d">&#9670;&nbsp;</a></span>updateArgumentVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::updateArgumentVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>argumentData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates specified vector argument. Possibly also modifies argument size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be updated. </td></tr>
    <tr><td class="paramname">argumentData</td><td>Pointer to new data for vector argument. Data types for old and new data have to match. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of elements inside updated vector argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89071adbe2f15811935caa5613ea4c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89071adbe2f15811935caa5613ea4c14">&#9670;&nbsp;</a></span>updateArgumentVectorAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::updateArgumentVectorAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>argumentData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates specified vector argument. Does not modify argument size. Argument will be updated asynchronously in specified queue. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be updated. </td></tr>
    <tr><td class="paramname">argumentData</td><td>Pointer to new data for vector argument. Number of elements and data types for old and new data have to match. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to update argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f850b561d79021d1613beb35b786b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f850b561d79021d1613beb35b786b0b">&#9670;&nbsp;</a></span>updateArgumentVectorAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktt::TuningManipulator::updateArgumentVectorAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacektt.html#aea210ff848d810aa544c225033ac26cb">ArgumentId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>argumentData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacektt.html#a42a11ff66d2e2aef76699a88f6602b0b">QueueId</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates specified vector argument. Possibly also modifies argument size. Argument will be updated asynchronously in specified queue. Note that asynchronous buffer operations are not yet supported for OpenCL buffers mapped into host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of vector argument which will be updated. </td></tr>
    <tr><td class="paramname">argumentData</td><td>Pointer to new data for vector argument. Data types for old and new data have to match. </td></tr>
    <tr><td class="paramname">numberOfElements</td><td>Number of elements inside updated vector argument. </td></tr>
    <tr><td class="paramname">queue</td><td>Id of queue in which the command to update argument will be submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/api/<a class="el" href="tuning__manipulator_8h_source.html">tuning_manipulator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacektt.html">ktt</a></li><li class="navelem"><a class="el" href="classktt_1_1_tuning_manipulator.html">TuningManipulator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
